<!--
@license
Copyright (c) 2018 Vaadin Ltd.
This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
-->

<link rel="import" href="../../polymer/polymer-element.html">
<link rel="import" href="../../vaadin-themable-mixin/vaadin-themable-mixin.html">
<link rel="import" href="../../vaadin-element-mixin/vaadin-element-mixin.html">
<script type="module" src="./vis-styles.js"></script>
<script src="../../vis/dist/vis-network.min.js"></script>

<link rel="import" href="./vcf-hierarchical-network-toolbar.html">

<dom-module id="vcf-hierarchical-network">
  <template>
    <style include="vis-styles">
      :host {
        display: flex;
        border: 1px solid var(--lumo-primary-color-50pct);
      }

      :host([hidden]) {
        display: none !important;
      }

      .canvas-container {
        background: #fafafa;
      }
    </style>
    <vcf-hierarchical-network-toolbar id="toolbar"></vcf-hierarchical-network-toolbar>
    <div id="main" class="canvas-container"></div>
  </template>

  <script>
    (function() {
      /**
       * @memberof Vaadin
       * @mixes Vaadin.ElementMixin
       * @mixes Vaadin.ThemableMixin
       * @demo demo/index.html
       */
      class VcfHierarchicalNetwork extends Vaadin.ElementMixin(Vaadin.ThemableMixin(Polymer.Element)) {
        static get is() {
          return 'vcf-hierarchical-network';
        }
        static get version() {
          return '0.1.0';
        }

        static get properties() {
          return {
            width: {
              type: Number,
              value: 800
            },
            height: {
              type: Number,
              value: 600
            },
            data: {
              type: Object,
              observer: '_dataChanged'
            },
            addingEdge: {
              type: Boolean,
              observer: '_addingEdge'
            },
            addingNode: {
              type: Boolean,
              observer: '_addingNode'
            },
            addingGroupNode: {
              type: Boolean,
              observer: '_addingGroupNode'
            },
            _parent: {
              type: Object,
              observer: '_setDimensions'
            },
            _options: {
              type: Object,
            },
            _network: {
              type: Object
            }
          };
        }

        connectedCallback() {
          super.connectedCallback();
          this._initNetwork();
          this._initEventListeners();
        }

        _setDimensions() {
          const parentBoundingRect = this._parent.getBoundingClientRect();
          const parentStyles = window.getComputedStyle(this._parent);
          let toolbarWidth = 0;
          if (this.$.toolbar) {
            toolbarWidth = this.$.toolbar.clientWidth;
          }
          if (!this._parent.style.width) {
            this.$.main.style.width = `${parseInt(parentStyles.width) - toolbarWidth}px`;
          } else {
            this.$.main.style.width = `${this._parent.style.width - toolbarWidth}px`;
          }
          if (!this._parent.style.height) {
            this.$.main.style.height = `calc(80vh - ${parentBoundingRect.top}px)`;
          } else {
            this.$.main.style.height = `${this._parent.style.height}px`;
          }
        }

        _initNetwork() {
          this._parent = this.parentNode.host;
          this._options = {
            physics: false,
            layout: {
              randomSeed: 42
            },
            nodes: {
              fixed: false,
              shape: 'box',
              borderWidth: 2,
              color: {
                background: '#ffffff',
                border: '#dadfe5',
                highlight: {
                  background: '#ffffff',
                  border: '#1576f3'
                }
              },
              font: {
                size: 10,
                color: 'rgba(27, 43, 65, 0.72)'
              },
              margin: {
                top: 12,
                right: 15,
                bottom: 12,
                left: 15
              }
            },
            edges: {
              length: 400,
              color: {
                color: '#dadfe5',
                highlight: '#90bbf9'
              }
            },
            manipulation: {
              enabled: false,
              addNode: this._addingNodeCallback.bind(this),
              addEdge: this._addingEdgeCallback.bind(this),
              controlNodeStyle: {
                shape: 'dot',
                size: 2,
                color: {
                  background: '#1576f3'
                },
                borderWidth: 0,
                borderWidthSelected: 0
              }
            }
          };
          this._network = new vis.Network(this.$.main, this._visDataset, this._options);
          this._manipulation = this._network.manipulation;
          this._canvas = this.shadowRoot.querySelector('canvas');
        }

        _initEventListeners() {
          this.$.toolbar.addEventListener('adding-node', e => this.addingNode = true);
          this.$.toolbar.addEventListener('adding-edge', e => this.addingEdge = true);
          this._network.on('hold', opt => {
            if (opt.nodes.length) {
              this.addingEdge = true;
              this._manipulation._handleConnect(opt.event);
              this._manipulation._temporaryBindUI('onRelease', e => {
                if (this._detectNode(e)) {
                  this._manipulation._finishConnect(e);
                } else {
                  this._reset();
                }
              });
            }
          });
        }

        _addingNode() {
          if (this.addingNode) {
            this._network.addNodeMode();
            this.addingEdge = false;
            this._canvas.style.cursor = 'crosshair';
          } else {
            this._canvas.style.cursor = 'default';
          }
        }

        _addingEdge() {
          if (this.addingEdge) {
            this._network.addEdgeMode();
            this.addingNode = false;
            this._canvas.style.cursor = 'crosshair';
          } else {
            this._canvas.style.cursor = 'default';
          }
        }

        _dataChanged(data) {
          if (data && (data.nodes.length || data.edges.length)) {
            this._network.setData({
              nodes: new vis.DataSet(data.nodes),
              edges: new vis.DataSet(data.edges)
            });
            setTimeout(() => {
              this._network.moveTo({
                scale: 2
              });
            });
          }
        }

        _addingNodeCallback(data, callback) {
          this.addingNode = false;
          this.$.toolbar.clear();
          this._canvas.style.cursor = 'default';
          callback(data);
        }

        _addingEdgeCallback(data, callback) {
          this.addingEdge = false;
          this._canvas.style.cursor = 'default';
          callback(data);
        }

        _detectNode(event) {
          const pointer = this._manipulation.body.functions.getPointer(event.center);
          const pointerObj = this._manipulation.selectionHandler._pointerToPositionObject(pointer);
          const overlappingNodeIds = this._manipulation.selectionHandler._getAllNodesOverlappingWith(pointerObj);
          let node = undefined;
          for (let i = overlappingNodeIds.length - 1; i >= 0; i--) {
            if (this._manipulation.temporaryIds.nodes.indexOf(overlappingNodeIds[i]) === -1) {
              node = this._manipulation.body.nodes[overlappingNodeIds[i]];
              break;
            }
          }
          return node;
        }

        _reset() {
          this.addingNode = false;
          this.addingEdge = false;
          this.$.toolbar.clear();
          this._manipulation._clean();
          this._manipulation._restore();
        }
      }

      customElements.define(VcfHierarchicalNetwork.is, VcfHierarchicalNetwork);

      /**
       * @namespace Vaadin
       */
      window.Vaadin.VcfHierarchicalNetwork = VcfHierarchicalNetwork;
    })();
  </script>
</dom-module>
